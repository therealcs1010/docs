= AlgoSenpai Adventures - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-T09-3/main

By: `CS2113T-T09-3`      Since: `Sept 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the application. Given below is a quick overview of each component.


`Main` has two classes called link:{repoURL}/src/main/java/com.algosenpai.app/Launcher.java[`Launcher`] and link:{repoURL}/src/main/java/com.algosenpai.app/MainAp.java[`MainApp`]. It is responsible for,

* At app launch: Initialising the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

The rest of the App consists of four components.

* <<Design-Ui,*`Ui`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor and the question generator.
* <<Design-Model,*`Stats`*>>: Holds the relevant user statistics and settings in memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

//Each of the four components
//
//* Defines its _API_ in an `interface` with the same name as the Component.
//* Exposes its functionality using a `{Component Name}Manager` class.
//
//For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

//.Class Diagram of the Logic Component
//image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `help`.

.Component interactions for `help` command
image::HelpSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`DialogBox`, `DialogBoxUser`.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `Parser` class to parse the user command.
.  This results in a `Command` object which is executed by the `Logic`.
.  The command execution will result in the `Ui` to generate a `DialogBox` on the screen.
.  The quiz is generated by the `QuizGenerator` using the `Chapter` classes in the `chapters` package.

//Given below is the Sequence Diagram for interactions within the `Logic` component for the `executeCommand("help")` API call.
//
//.Interactions Inside the Logic Component for the `help` Command
//image::DeleteSequenceDiagram.png[]

==== Parser Component

When the user inputs a command, the command will be parsed through by the parser class, checking for the validity of the command by comparing it with the enum of commands.

. If valid, the command will be split by the spaces in between them and stored into an arraylist. (e.g. `select 3` will be split into {select, 3})
    - The logic class will then call for the first string in the arraylist, in which it will be used to determine which command to call for next.
. If invalid, the InvalidCommand class will be called for, whereby the user will be notified to input a valid command: `error please input a valid command`.

image::ParserandCommandClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` class handles the reading and writing of user data to and from text files. It consists of two methods:

* `saveData`: Takes in a filename and a string, saves the string to the filename.
* `loadData`: Takes in a filename, returns the text in that file as a string.

A few implementation details to take note of:

. The `Storage` class only has static methods. This means that you do should not instantiate the object. The reasons
for doing this are:
- The class does not need to hold any state because of it's simple task,
so it does not make sense to instantiate an object.
- It is much more convenient to use, as you do not need to create a new `Storage` object for every storage operation.
. The methods handle strings, instead of the object that is being stored/retrieved.
This is so that methods can operate independently of what is being stored. The converting the object
to string and vice-versa has to be handled within that class. This pattern reduces coupling.
- The one situation which breaks this rule is when `loadData` is done on a file that doesn't exist yet.
In the current version, a default `UserStats` object is returned. Ideally this will be changed for the final version.

[[Design-UserData]]
=== Stats component

.Structure of the Stats Component
image::StatsClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The Stats component defines what data is stored permanently. It includes information about the user, and the
statistics for each chapter (such as correct answer %, number of attempts).

[discrete]
==== Relationship between Stats and `Storage`
The `Storage` component is used to store
this data permanently and retrieve it from storage later. An instance of `UserStats` is used to hold
and modify the data during runtime.

[discrete]
==== Description of the classes
* `ChapterStat` holds the statistics about the quiz attempts for that chapter, such as answer %, and number of attempts.
* `UserStats` holds an ArrayList of `ChapterStat` s, one for each chapter. It also holds some additional information
about the user, such as name, gender.

[discrete]
==== How to handle storage
Each class has a `toString` method that converts the data in that object to a string representation that can be
stored in the text file. If the name of your `UserStats` instance is `userStats`, pass
 `userStats.toString()` as the parameter to `Storage.saveData()`.

Similarly, each class has a static `parseString()` to convert a string to the object. Pass the result of
`Storage.loadData()` to `UserStats.parseString()` to get the `UserStats` object.

Note that `ChapterStat` has its own `parseString` and `toString` methods which are used by the corresponding `UserStats`
methods. This is done so increase modularity.

IMPORTANT: When editing the `toString` method, make sure to edit the corresponding `parseString` method (and vice-versa)

[discrete]
==== How to use `UserStats`
* Use the `currentChapter` object to hold stats for the current chapter while it is being played. Afterwards,
use `saveCurrentChapterToChapterData` to transfer the relevant data from `currentChapter` to the appropriate
element in the `chapterData` ArrayList.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::print[]
=== [Proposed] Printing Archived/Quiz/UserStats features
==== Proposed Implementation
This feature allows the user print the attempted quiz, the archived questions and his/her profile to PDF. The user has
to input `print archive` into the text field to print the archived questions, `print quiz` to print the quiz questions,
and `print report` to print the user profile. `PrintArchiveCommand` is used to print to archive questions to PDF, and
`PrintReportCommand` for the user stats, and `PrintQuizCommand` for the quiz. The `PrintArchiveCommand`,
`PrintQuizCommand`, and `PrintReportCommand` is a children class of `PrintCommand`.

image::PrintCommandImplementation.png[]

==== Design Considerations
===== Aspect: Modularizing program to write to PDF
* **Alternative 1 (current choice):** Use inheritance.
** Pros: Allow future expansion for specific commands, share the inherited method `saveToPdf` from the `PrintCommand` to write the data into PDF.
** Cons: Increase storage size and memory usage from multiple files and instances.
* **Alternative 2:** Use overloading.
** Pros: Convenient to parse the data to write to PDF.
** Cons: Difficult to develop other features to print to PDF in future.

// tag::audio[]
=== [Proposed] Playing Audio features
==== Proposed Implementation
This feature allows the user play in-built music while he/she uses the application. The music will be randomly chosen
and played. Once the music ends, another music start playing. The user can input `sound <sound level>` to adjust the
sound level. For example, `sound 0` means the music is off, while `sound 10` means the music is played at maximum
intensity. This feature is separated into `MusicController` and instantiated in the `MainApp`.

==== Design Considerations
===== Aspect: Tracking when to play the next music
* **Alternative 1 (current choice):** Use multi-threading to playing the music.
** Pros: Reduce timing overhead due to asynchronous execution.
** Cons: Code is not able to reuse.
* **Alternative 2:** Use the `AnimationTimer` in `JavaFx` to poll and check the music status.
** Pros: Easy to implement and reuse `AnimationTimer`.
** Cons: Additional overhead for the `AnimationTimer` due to synchronous execution.

===== Aspect: Data structure to contain the music
* **Alternative 1 (current choice):** Use a `HashMap` to store the list of music.
** Pros: Easy to store and track the music name in a `HashMap` using `SoundEnum`
** Cons: Need to convert to a list of string to display music name on the user interface.
* **Alternative 2:** Use `List` to store the music
** Pros: Easy to random a music, display music on the user interface, and search for the music name in a list.
** Cons: More prone to mistakes when handling the music names in `String`.

// tag::improvisedparser[]
=== [Proposed] Improvising on current parser

==== The Proposed Implementation

While the current parser serves its purpose, we seek to implement a `Did you mean...` feature, where rather than just returning `???!` to the user,
it also returns the command that is most similar to what the user has inputted.

For example, unnecessary spaces in between such as `me n u` or with an accidental typo such as `seect` will be taken into consideration and the word that is most similar to it will be derived and return `Did you mean.. menu?` and `Did you mean.. select?`

==== Design Considerations

===== Aspect: How the improvised parser works

- It will be implemented under the invalid command, where the input string will be compared with the enum of commands, and returning the string that has the most number of similar characters to whatever the user has inputted.

    Pros:
    - It is easy to implement
    - Will be more user friendly
    - Saves time and allows user to have a better overall experience

===== Aspect: Data structure to support the improvisation of parser

- Function to compare the number of similar characters between two strings will be needed
- Function to pick out the command that is most similar to the command entered by the user will be needed

// end::improvisedparser[]


// tag::reset[]
=== [Proposed] Reset Command

==== Proposed Implementation

The reset command is to be implemented to remove all the existing data the system has about the user.
That means that the storage is cleared, and there will be no history on the past quizzes attempted and the scores.

==== Design Considerations

===== Aspect: How reset command works

- User just has to enter `reset`
- System will then notify the user that such an action cannot be undone and will seek the user's confirmation
`Are you sure you want to reset? Data removed will not be retrievable. Y/N`

===== Aspect: Data structure to support the reset command

- A reset command extending the existing command class will be needed

- Under the execute() block, the storage will then be called for it to be cleared.

    Pros: Efficient memory allocation as user can decide when to reset

// end::reset[]

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.


[appendix]
== Product Scope

*Target user profile*:

- Wants to improve concepts in data structures and algorithms
- Wants to become faster at answering questions
- Dislikes learning concepts theoretically
- Prefers elements of fun in their learning
- Finds VisuAlgo boring, repetitive, and tedious to use

*Value Proposition*:
Offer a more time efficient, and fun platform to learn and practice data structures and algorithms.

[appendix]
== Requirements

=== User Stories
Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
| * * * | New User | See a summary of the commands available in the program | Have a brief idea of how to navigate through the program.
| * * * | User | Start the game | Start learning concepts immediately.
| * * * | User | Pause the game | Save the current quiz records and take a break.
| * * * | User | End the game | See the results for the current quiz.
| * * * | User | Go back to the previous question | Review the question and change my answer if necessary.
| * * * | User | Skip to the next question of the game | Move on to other questions that I am more confident in to avoid spending too much time on a single question.
| * * * | Weak User | See the results of the previous games I have played | Can see a tangible improvement in my quiz scores.
| * * * | Weak User | Choose to attempt the game only on a certain chapter | Work on my weaker areas.
| * * * | User | Continue the game which I have previously ended off with | Save time on trying to find out where I last ended off.
| * * * | User | Have an undo button | Reverse my actions if I typed the wrong command.
| * *  | User | Share and spread this game to my friends | Invite them to learn together.
| * *  | Average User | Get feedback on my performance | Identify my common misconceptions and work on those areas.
| * *  | User | Provide feedback to developers | Give them suggestions on what they can improve on.
| * *  | User | Receive notifications and reminders to complete a few games a day | Be more consistent with my learning.
| * *  | Easily Bored User | Experience a storyline | Learn in a less boring manner.
| * *  | Weak User | Have pictorial representations for the questions | Visualise the question better.
| * *  | Weak User | Have an explanation for any wrong answers | Learn faster from my mistakes.
| * *  | Strong User | Have a time limit | Challenge myself to perform better.
| * *  | Strong User | Have an arcade mode | Challenge myself to see how proficient I am in a topic.
| * *  | Weak User | Have a multiple choice option rather than open-ended | Practice on my concepts before attempting harder questions.
| * *  | User | Have a reset option | Replay the game if I'm done with the storyline.
| *  | Weak User | Clarify certain concepts with a virtual agent/chatbot | Build a stronger foundation for my weaker topics.
| *  | User | Be challenged every time I play the game | Improve incrementally as I play it more.
| *  | Advanced User | Get updates whenever the program has new levels | Explore new concepts and increase my understanding in data structures and algorithms.
| * * * | User | Set a to-do for certain topics   | Gradually pick up skills in programming without feeling overwhelmed.
| * * * | User | Get a reminder for my to-do chapters | Be notified if I have not revised on a particular topic.
| *  | User | Customise my own questions `[coming in v2.0]` | Test myself on questions I know I'm weak at.
| *  | User | Choose which character to play in the game `[coming in v2.0]` | Vary the experience I have in every game.
| * * | User | See my overall progress since I started the game `[coming in v2.0]`| See how much I have improved and learnt since then.
| * * | User | Have a recap section `[coming in v2.0]`| Have a quick reference to the topics without leaving the game.
| * | Competitive User | Have rewards in-game `[coming in v2.0]`| Feel motivated to clear the entire game.
|=======================================================================


=== Use Cases
(For all use cases below, the System is `AlgoSenpai` and the Actor is the `Student`, unless specified otherwise)

[discrete]
==== Play through a story
. User launches the game
. System starts and displays a welcome message
. User requests for the list of available stories
. System displays the list of stories
. User chooses a story to play
. System starts displaying questions from the story
. User enters an answer
. System displays the next question
. User enters an answer
(Steps 8 - 9 repeats until the game is over)
. System shows the result and returns to the main menu


[discrete]
===== Extensions
- User enters an invalid command/answer.

. System shows an error message and prompts the user to input a valid command
. User inputs a new command (Steps 1 and 2 repeats till the user has entered a valid command)


[discrete]
==== UC01: Have a summary of commands
. User enters the `menu` command
. System displays a list of commands

Use case ends.

[discrete]
==== UC02: Start quiz
. User enters the `start` command
. System displays the first question of the quiz

Use case ends.

[discrete]
==== UC03: Pause quiz
. User enters the `pause` command
. System pauses the ongoing quiz

Use case ends.

[discrete]
==== UC04: End quiz
. User enters the `end` command
. System exits user from the current quiz and shows him/her the results

Use case ends.

[discrete]
==== UC05: Revisit attempted questions
. User enters the `previous` command
. System displays the previous question

Use case ends.

[discrete]
==== UC06: Move to the next question
. User enters the `next` command
. System displays the next question

Use case ends.

[discrete]
==== UC07: View the history of the attempted quizzes
. User enters the `history` command
. System displays the results of all the quizzes attempted by the user

Use case ends.

[discrete]
==== UC08: Attempt quiz of a topic
. User enters the `chapters` command
. System displays the list of chapters
. User enters the number corresponding to the topic he/she would like to attempt
. System displays the first question of the selected chapter

Use case ends.

[discrete]
==== UC09: Resume quiz
. User enters the `resume` command
. System displays the next question from the uncompleted quiz

Use case ends.

[discrete]
==== UC10: Undo my answers
. User enters the `undo` command
. System  the previous action done by the user

Use case ends.

[discrete]
==== UC11: Share this game with my friends
. User enters the `share` command
. System displays the social media platforms for the user to choose from
. User selects one
. System displays a pop up message "This will be opened in a separate window, do you wish to continue? Y/N"
. User enters "Y" (If user accidentally entered "N", he/she will be redirected to the menu)
. User then selects the contact he/she wishes to send the invite to

Use case ends.

[discrete]
==== UC12: Get review on my performance
. User enters the `review` command
. System displays the review generated by a virtual agent

Use case ends.

[discrete]
==== UC13: Provide feedback to developers
. User enters the `feedback` command
. System displays "A separate window will be opened, do you wish to continue? Y/N"
. User enters "Y" (If the user accidentally enters "N", he/she will be redirected to the menu)
. A google form window is opened for the user to fill up

Use case ends.

[discrete]
==== UC14: Receive remainders for quizzes
. User enters the `settings` command
. System displays the settings menu
. User enters the timing(s) he/she would like to receive the reminders under the "reminder" window
. System will display a pop-up reminding the user to complete the quizzes at the specified timings

Use case ends.

[discrete]
==== UC15: Get help
. User enters the `help` command
. System displays the help menu

Use case ends.

[discrete]
==== UC16: Learn through animations
. User enters the `settings` command
. System displays the settings menu
. User clicks on for the animation section
. System turns on animations and returns to the quiz

Use case ends

[discrete]
==== UC17: View explanations for wrong answers
. User enters `help` command
. System displays the help menu
. User clicks on "explanation" and enters the question number he requires explanation for
. System displays the explanation for the selected question

Use case ends

[discrete]
==== UC18: Set time limit
. User enters `settings` command
. System displays the settings menu
. User inputs a number under the time limit section

Use case ends

[discrete]
==== UC19: Have a quest to complete
. User enters `quest` command
. System displays the list of quests available

Use case ends

[discrete]
==== UC20: Have MCQ instead of open-ended ones
. User enters `mode` command
. System displays the mode menu
. User clicks on "MCQ"

Use case ends

[discrete]
==== UC21: Have a reset option
. User enters `reset` command
. System clears all existing answers
. System displays the first question of the current quiz

Use case ends

[discrete]
==== UC22: Clarify concepts with an agent 24/7
. User enters `help` command
. System displays the help menu
. User opts for a live agent
. System starts a live chat with a live agent

Use case ends

[discrete]
==== UC23: Share my highest score with my friends
. User enters `history` command
. User enters `share` command
. System displays the social media platforms for the user to choose from
. User selects one
. System displays a pop up message "This will be opened in a separate window, do you wish to continue? Y/N"
. User enters "Y" (If user accidentally entered "N", he/she will be redirected to the menu)
. System displays a default post on the selected social media platform
. User can type his/her own caption and proceed to upload it

Use case ends

[discrete]
==== UC24: Print the quiz to pdf
. User enters `print` command
. System converts file to pdf and proceeds with the command

Use case ends

[discrete]
==== UC25: Listen to music during the quiz
. User enters `settings` command
. System displays settings menu
. User selects a playlist
. System starts to play the playlist and returns back to the menu/quiz

Use case ends

[discrete]
==== UC26: Archive difficult questions
. User enters `help` command
. System displays the help menu
. User clicks on "archive"
. System automatically archives the question the user is on

[discrete]
==== UC27: Take screenshots of the students' results
Actor: Tutor

. User enters `screenshot` command
. System automatically saves the screenshot into the user's hard disk

Use case ends

[discrete]
==== UC28: Interact with characters in the game
. User enters `interact` command
. System displays the list of users who are online
. User selects another user and a chat page pops up

Use case ends

[discrete]
==== UC29: Refer to the algorithms
. User enters `settings` command
. System displays the settings menu
. User selects "algorithm" option

Use case ends

[discrete]
==== UC30: Choose an answer verbally
. User enters `settings` command
. System displays the settings menu
. User selects "microphone" option

Use case ends


=== Non Functional Requirements

- The application should work on any mainstream OS with Java 11 installed to run the game.
- The computer should have a minimum of 320 by 300 screen resolution for the game to display.
- The computer should have a minimum of Intel I3 dual core processors for the game to run without notable sluggish.
- The user should be able to read, understand, and write English to complete the storyline in the game.
- The computer should have minimum 4GB of RAM to load the game.
- The user should be at least 16 years of age due to mature content.


[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X


[appendix]
== Product Survey


[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the splash screen initially and then the main window will show with the welcome message. The window should be fixed.

. Exiting the program

.. Type `exit` into the user input box.
.. Expected: Application will shut down and close itself. +


=== Playing the quiz

. Starting and playing the quiz

.. Prerequisites: The user must not be in the quiz mode yet. Start the quiz mode using the `start` command.
.. Test case: `1` +
   Expected: The quiz will consume the user input as it will identify the input as the answer to the current question
   displayed and then show the next question in the quiz.
.. Test case: `back` +
   Expected: The previous question of the current quiz will be displayed. The user can then enter the
   answer to the current question.

_{ more test cases ... }_

=== Saving data


_{ more test cases ... }_

